## 字符串的排列
<!--START_SECTION:badge-->
![last modify](https://img.shields.io/static/v1?label=last%20modify&message=2025-07-08%2016%3A53%3A13&label_color=gray&color=thistle&style=flat-square)
[![](https://img.shields.io/static/v1?label=&message=%E4%B8%AD%E7%AD%89&label_color=gray&color=yellow&style=flat-square)](../../../README.md#中等)
[![](https://img.shields.io/static/v1?label=&message=%E7%89%9B%E5%AE%A2&label_color=gray&color=green&style=flat-square)](../../../README.md#牛客)
[![](https://img.shields.io/static/v1?label=&message=%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2&label_color=gray&color=blue&style=flat-square)](../../../README.md#深度优先搜索)
[![](https://img.shields.io/static/v1?label=&message=%E7%BB%8F%E5%85%B8&label_color=gray&color=blue&style=flat-square)](../../../README.md#经典)
<!--END_SECTION:badge-->
<!--info
tags: [DFS, 经典]
source: 牛客
level: 中等
number: '0121'
name: 字符串的排列
companies: []
-->

> [字符串的排列_牛客题霸_牛客网](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7)

<summary><b>问题简述</b></summary>

```txt
输入一个长度为 n 字符串, 打印出该字符串中字符的所有排列, 你可以以任意顺序返回这个字符串数组.
例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB.
```

<!--
<details><summary><b>详细描述</b></summary>

```txt
```

</details>
-->

<!-- <div align="center"><img src="../../../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1: N叉树的前序遍历</b></summary>

- 排列的一般思路 (假设无重复) :
    - 第 1 位有 n 种可能, **固定第 1 位后**第 2 位有 n-1 种可能、**固定前 2 位后**第 3 位有 n-2 种可能、...、**固定前 n - 1 位后**第 n 位有 1 种可能;
    - 即时间复杂度为 `O(n!)`, 如果无法理解`O(n!)`的含义, 就很可能写出错误的代码;
    - 具体来说, 以 `[1,2,3]` 为例, 第一位有 3 种可能, 当固定第一位为 `1` 时, 第二位有 `[2,3]` 两种可能, 当固定第一位为 `2` 时, 第二位依然有两种可能 `[1,3]`;
- 写法1) 基于枚举 (**剪枝需要排序**)
    - 使用一个全局变量记录已经用过的字符;
    - 去重方法:
        > [剑指 Offer 38. 字符串的排列 - 代码随想录](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/dai-ma-sui-xiang-lu-jian-zhi-offer-38-zi-gwt6/)
        - `if i > 0 and s[i] == s[i - 1] and not used[i - 1]: continue`;
- 写法2) 基于交换 (**剪枝不需要排序**)
    > [剑指 Offer 38. 字符串的排列 (回溯法, 清晰图解) - Krahets](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/)
    - 去重方法: 在 dfs 内部记录使用过的字符;

- 写法 2 不需要排序, 写起来也更简单; 但是写法 1 可以返回字典序的排序, 写法 2 做不到;


<details><summary><b>Python 写法1) 基于枚举</b></summary>

```python
class Solution:
    def Permutation(self , s: str) -> List[str]:

        N = len(s)
        s = sorted(list(s))
        used = [0] * N
        ret = []

        def dfs(d, tmp):
            if d == N:
                ret.append(''.join(tmp[:]))
                return

            for i in range(N):
                # 基于树枝的剪枝
                # if i > 0 and s[i] == s[i - 1] and used[i - 1]:
                    # continue

                # 基于树层的剪枝 (效率更高)
                if i > 0 and s[i] == s[i - 1] and not used[i - 1]:
                    continue

                if not used[i]:
                    used[i] = 1
                    tmp.append(s[i])
                    dfs(d + 1, tmp)
                    tmp.pop()
                    used[i] = 0

        dfs(0, [])
        return ret
```

</details>


<details><summary><b>Python 写法2) 基于交换</b></summary>

```python
class Solution:
    def Permutation(self, s: str) -> List[str]:

        n = len(s)
        s = list(s)
        ret = []

        def dfs(d):
            if d == n:
                ret.append(''.join(s))
                return

            book = set()  # 记录用过的字符 (剪枝)
            for i in range(d, n):  # 遍历 s[d] 及之后的字符
                if s[i] not in book:
                    book.add(s[i])
                    s[d], s[i] = s[i], s[d]  # 交换
                    dfs(d + 1)
                    s[d], s[i] = s[i], s[d]  # 回溯
                    # book.remove(s[i])  # err, 不需要清除标记

        dfs(0)
        return ret
```

</details>


<summary><b>思路2: 下一个排列</b></summary>

- 先排序得到最小的字典序结果;
- 循环直到不存在下一个更大的排列;
- 下一个排列 思路:
    - 为了使下一个排列更大, 一个方法是将一个左边的「较小数」与一个右边的「较大数」交换;
    - 而为了使变大的幅度最小, 需要让这个「较小数」尽量靠右, 而「较大数」尽可能小.
    - 实现起来并没有那么直观, 详见代码;

<details><summary><b>Python</b></summary>

```python
class Solution:
    def Permutation(self, s: str) -> List[str]:

        def next_permutation(a: List[str]) -> bool:
            N = len(a)

            # 从后向前查找第一个相邻顺序对 (i, i+1), 即满足 a[i] < a[i+1];
            # 此时 `a[i+1:n)` 必为递减序列
            i = N - 2
            while i >= 0 and a[i] >= a[i + 1]:
                i -= 1

            if i < 0:  # i < 0, 表示 a[0:n) 都是递减, 即为最大排列
                return False
            else:
                # 在 a[i+1:n) 中从后往前查找第一个 j 满足 a[i] < a[j]
                j = N - 1
                while j >= 0 and a[i] >= a[j]:
                    j -= 1
                # 至此, 找到了 靠左的 "较小数" 和 靠右的 "较大数" , 交换
                a[i], a[j] = a[j], a[i]

            # 将 a[i+1:n) 反转, 此时 a[i+1:n) 必为递减序列;
            l, r = i + 1, N - 1
            while l < r:
                a[l], a[r] = a[r], a[l]
                l += 1
                r -= 1

            return True

        buf = sorted(s)
        ret = [''.join(buf)]
        while next_permutation(buf):
            ret.append(''.join(buf))

        return ret
```

</details>
<!--START_SECTION:relate-->
---

### 相关主题

<details><summary><b>深度优先搜索</b></summary>

> [[中等, LeetCode] 括号生成 🔥](../10/LeetCode_0022_中等_括号生成.md)  
> [[中等, LeetCode] 电话号码的字母组合 🔥](../10/LeetCode_0017_中等_电话号码的字母组合.md)  
> [[中等, LeetCode] 组合总和 🔥](../10/LeetCode_0039_中等_组合总和.md)  
> [[中等, LeetCode] 路径总和III](../06/LeetCode_0437_中等_路径总和III.md)  
> [[中等, 剑指Offer] 二叉树中和为某一值的路径](../../2021/12/剑指Offer_3400_中等_二叉树中和为某一值的路径.md)  
> [[中等, 剑指Offer] 字符串的排列（全排列） 🔥](../../2021/12/剑指Offer_3800_中等_字符串的排列（全排列）.md)  
> [[中等, 剑指Offer] 打印从1到最大的n位数（N叉树的遍历）](../../2021/11/剑指Offer_1700_中等_打印从1到最大的n位数（N叉树的遍历）.md)  
> [[中等, 剑指Offer] 机器人的运动范围](../../2021/11/剑指Offer_1300_中等_机器人的运动范围.md)  
> [[中等, 剑指Offer] 矩阵中的路径](../../2021/11/剑指Offer_1200_中等_矩阵中的路径.md)  
> [[中等, 牛客] 二叉树中和为某一值的路径(二)](../01/牛客_0008_中等_二叉树中和为某一值的路径(二).md)  
> [[中等, 牛客] 二叉树根节点到叶子节点的所有路径和](../01/牛客_0005_中等_二叉树根节点到叶子节点的所有路径和.md)  
> [[中等, 牛客] 实现二叉树先序、中序、后序遍历](../03/牛客_0045_中等_实现二叉树先序、中序、后序遍历.md)  
> [[中等, 牛客] 岛屿数量 🔥](../04/牛客_0109_中等_岛屿数量.md)  
> [[中等, 牛客] 数字字符串转化成IP地址](../01/牛客_0020_中等_数字字符串转化成IP地址.md)  
  > 
> [[困难, 牛客] 多叉树的直径](../04/牛客_0099_困难_多叉树的直径.md)  
  > 
> [[简单, LeetCode] 二叉树的最小深度](../07/LeetCode_0111_简单_二叉树的最小深度.md)  
> [[简单, 剑指Offer] 二叉搜索树的第k大节点](../01/剑指Offer_5400_简单_二叉搜索树的第k大节点.md)  
> [[简单, 剑指Offer] 从尾到头打印链表](../../2021/11/剑指Offer_0600_简单_从尾到头打印链表.md)  
> [[简单, 牛客] 二叉树中和为某一值的路径(一)](../01/牛客_0009_简单_二叉树中和为某一值的路径(一).md)  
  > 

</details>
<details><summary><b>经典</b></summary>

> [[中等, LeetCode] 下一个排列 🔥](../10/LeetCode_0031_中等_下一个排列.md)  
> [[中等, LeetCode] 二叉树的完全性检验 🔥](../03/LeetCode_0958_中等_二叉树的完全性检验.md)  
> [[中等, LeetCode] 最长递增子序列 🔥](../06/LeetCode_0300_中等_最长递增子序列.md)  
> [[中等, 剑指Offer2] 整数除法 🔥](../09/剑指Offer2_001_中等_整数除法.md)  
> [[中等, 剑指Offer] 丑数 🔥](../../2021/12/剑指Offer_4900_中等_丑数.md)  
> [[中等, 剑指Offer] 二叉搜索树与双向链表 🔥](../../2021/12/剑指Offer_3600_中等_二叉搜索树与双向链表.md)  
> [[中等, 剑指Offer] 圆圈中最后剩下的数字（约瑟夫环问题） 🔥](../01/剑指Offer_6200_中等_圆圈中最后剩下的数字（约瑟夫环问题）.md)  
> [[中等, 剑指Offer] 复杂链表的复制（深拷贝） 🔥](../../2021/12/剑指Offer_3500_中等_复杂链表的复制（深拷贝）.md)  
> [[中等, 剑指Offer] 字符串的排列（全排列） 🔥](../../2021/12/剑指Offer_3800_中等_字符串的排列（全排列）.md)  
> [[中等, 剑指Offer] 把字符串转换成整数 🔥](../01/剑指Offer_6700_中等_把字符串转换成整数.md)  
> [[中等, 剑指Offer] 数值的整数次方（快速幂） 🔥](../../2021/11/剑指Offer_1600_中等_数值的整数次方（快速幂）.md)  
> [[中等, 剑指Offer] 栈的压入、弹出序列 🔥](../../2021/11/剑指Offer_3100_中等_栈的压入、弹出序列.md)  
> [[中等, 剑指Offer] 重建二叉树 🔥](../../2021/11/剑指Offer_0700_中等_重建二叉树.md)  
> [[中等, 剑指Offer] 顺时针打印矩阵（3种思路4个写法） 🔥](../../2021/11/剑指Offer_2900_中等_顺时针打印矩阵（3种思路4个写法）.md)  
> [[中等, 牛客] 01背包 🔥](牛客_0145_中等_01背包.md)  
> [[中等, 牛客] 丢棋子问题（鹰蛋问题） 🔥](../04/牛客_0087_中等_丢棋子问题（鹰蛋问题）.md)  
> [[中等, 牛客] 寻找峰值 🔥](../04/牛客_0107_中等_寻找峰值.md)  
> [[中等, 牛客] 岛屿数量 🔥](../04/牛客_0109_中等_岛屿数量.md)  
> [[中等, 牛客] 把字符串转换成整数(atoi) 🔥](../04/牛客_0100_中等_把字符串转换成整数(atoi).md)  
> [[中等, 牛客] 数组中只出现一次的两个数字 🔥](../03/牛客_0075_中等_数组中只出现一次的两个数字.md)  
> [[中等, 牛客] 最长公共子序列(二) 🔥](../04/牛客_0092_中等_最长公共子序列(二).md)  
> [[中等, 牛客] 栈和排序 🔥](牛客_0115_中等_栈和排序.md)  
> [[中等, 牛客] 汉诺塔问题 🔥](../03/牛客_0067_中等_汉诺塔问题.md)  
  > 
> [[困难, LeetCode] 编辑距离 🔥](../06/LeetCode_0072_困难_编辑距离.md)  
> [[困难, 剑指Offer] 数组中的逆序对 🔥](../01/剑指Offer_5100_困难_数组中的逆序对.md)  
> [[困难, 牛客] 接雨水问题 🔥](牛客_0128_困难_接雨水问题.md)  
> [[困难, 牛客] 设计LFU缓存结构 🔥](../04/牛客_0094_困难_设计LFU缓存结构.md)  
> [[困难, 牛客] 设计LRU缓存结构 🔥](../04/牛客_0093_困难_设计LRU缓存结构.md)  
  > 
> [[简单, LeetCode] 二叉树的最大深度 🔥](../07/LeetCode_0104_简单_二叉树的最大深度.md)  
> [[简单, LeetCode] 反转链表 🔥](../10/LeetCode_0206_简单_反转链表.md)  
> [[简单, 剑指Offer] 二叉搜索树的最近公共祖先 🔥](../01/剑指Offer_6801_简单_二叉搜索树的最近公共祖先.md)  
> [[简单, 剑指Offer] 反转链表 🔥](../../2021/11/剑指Offer_2400_简单_反转链表.md)  
> [[简单, 剑指Offer] 数组中出现次数超过一半的数字（摩尔投票） 🔥](../../2021/12/剑指Offer_3900_简单_数组中出现次数超过一半的数字（摩尔投票）.md)  
> [[简单, 剑指Offer] 最小的k个数（partition操作） 🔥](../../2021/12/剑指Offer_4000_简单_最小的k个数（partition操作）.md)  
> [[简单, 牛客] 二进制中1的个数 🔥](牛客_0120_简单_二进制中1的个数.md)  
> [[简单, 牛客] 单链表的排序 🔥](../03/牛客_0070_简单_单链表的排序.md)  
> [[简单, 牛客] 求平方根 🔥](../02/牛客_0032_简单_求平方根.md)  
  > 

</details>
<!--END_SECTION:relate-->