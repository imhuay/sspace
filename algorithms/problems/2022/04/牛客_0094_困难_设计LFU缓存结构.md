## 设计LFU缓存结构
<!--START_SECTION:badge-->
![last modify](https://img.shields.io/static/v1?label=last%20modify&message=2025-07-08%2016%3A53%3A13&label_color=gray&color=thistle&style=flat-square)
[![](https://img.shields.io/static/v1?label=&message=%E5%9B%B0%E9%9A%BE&label_color=gray&color=yellow&style=flat-square)](../../../README.md#困难)
[![](https://img.shields.io/static/v1?label=&message=%E7%89%9B%E5%AE%A2&label_color=gray&color=green&style=flat-square)](../../../README.md#牛客)
[![](https://img.shields.io/static/v1?label=&message=%E8%AE%BE%E8%AE%A1&label_color=gray&color=blue&style=flat-square)](../../../README.md#设计)
[![](https://img.shields.io/static/v1?label=&message=%E7%BB%8F%E5%85%B8&label_color=gray&color=blue&style=flat-square)](../../../README.md#经典)
<!--END_SECTION:badge-->
<!--info
tags: [设计, 经典]
source: 牛客
level: 困难
number: '0094'
name: 设计LFU缓存结构
companies: []
-->

> [设计LFU缓存结构_牛客题霸_牛客网](https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1)

<summary><b>问题简述</b></summary>

```txt
设计LFU(最近最少频次使用)缓存结构.
```

<!--
<details><summary><b>详细描述</b></summary>

```txt
```

</details>
-->


<!-- <div align="center"><img src="../../../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 定义 `key2cnt` 保存 key 的操作频数; `cnt2key` 保存各频数的 key 队列;
    - `cnt2key` 中可以使用 dict (只使用 key) 作为有序 set 代替队列, 提升删除效率;
- 定义 `refresh`, 每次操作后更新 cnt 队列;
- 定义 `least` 保存当前最少的频数;
    - 每次有新 key 进来时, 重置 `least` 为 1;
    - 每次更新 cnt2key 后, 如果当前的队列为空且等于 `least`, 需要`least += 1`;

<details><summary><b>Python 写法1</b></summary>

```python
class Solution:
    from collections import defaultdict, deque
    k: int  # 容量
    least = 1  # 记录当前最少频次
    key2val = dict()
    key2cnt = defaultdict(int)  # 这个和 key2val 可以合并在一起可以省一组 key, 这里为了更清晰分开存储
    cnt2key = defaultdict(dict)  # 这里实际只用到了 dict 的 key 作为有序 set

    def refresh(self, key):
        cnt = self.key2cnt[key]
        self.cnt2key[cnt].pop(key)
        if len(self.cnt2key[cnt]) == 0:
            self.cnt2key.pop(cnt)
            if self.least == cnt:
                self.least += 1
        self.key2cnt[key] += 1
        self.cnt2key[cnt + 1][key] = None  # 因为只用了 key,

    def get(self, key):
        ret = self.key2val.get(key, -1)
        if key in self.key2val:
            self.refresh(key)
        return ret

    def set(self, key, value):
        if key not in self.key2val:
            # 超容量的情况
            if len(self.key2val) >= self.k:
                tmp = next(iter(self.cnt2key[self.least]))
                # 全部 pop
                self.cnt2key[self.least].pop(tmp)
                self.key2val.pop(tmp)
                self.key2cnt.pop(tmp)
            self.key2val[key] = value
            self.key2cnt[key] += 1
            self.cnt2key[self.key2cnt[key]][key] = None
            self.least = 1  # 因为是新的 key, 所以显然最少频次将更新为 1
        else:
            self.refresh(key)
            self.key2val[key] = value

    def LFU(self , operators: List[List[int]], k: int) -> List[int]:
        self.k = k

        ret = []
        for op in operators:
            if op[0] == 1:
                self.set(op[1], op[2])
            else:
                ret.append(self.get(op[1]))

        return ret
```

</details>

- 写法 2 的区别仅在于将 `key2cnt` 和 `key2val` 合并在一起, 省了一组 `key` 的空间;

<details><summary><b>Python 写法2</b></summary>

```python
class Solution:
    from collections import defaultdict, deque
    k: int  # 容量
    least = 1  # 记录当前最少频次
    key2cnt = dict()  # 出了保存频次, 也保存了值
    cnt2key = defaultdict(dict)  # 这里实际只用到了 dict 的 key 作为有序 set
    # 这里也可以使用队列, 但是删除效率应该不如 set

    def refresh(self, key):
        cnt = self.key2cnt[key][0]
        self.cnt2key[cnt].pop(key)
        if len(self.cnt2key[cnt]) == 0:
            self.cnt2key.pop(cnt)
            if self.least == cnt:
                self.least += 1
        self.key2cnt[key][0] += 1
        self.cnt2key[cnt + 1][key] = None  # 因为只用了 key,

    def get(self, key):
        ret = self.key2cnt[key][1] if key in self.key2cnt else -1
        if key in self.key2cnt:
            self.refresh(key)
        return ret

    def set(self, key, value):
        if key not in self.key2cnt:
            # 超容量的情况
            if len(self.key2cnt) >= self.k:
                tmp = next(iter(self.cnt2key[self.least]))
                # 全部 pop
                self.cnt2key[self.least].pop(tmp)
                self.key2cnt.pop(tmp)
            cnt = 1
            self.key2cnt[key] = [cnt, value]
            self.cnt2key[cnt][key] = None
            self.least = 1  # 因为是新的 key, 所以显然最少频次将更新为 1
        else:
            self.refresh(key)
            self.key2cnt[key][1] = value

    def LFU(self , operators: List[List[int]], k: int) -> List[int]:
        self.k = k

        ret = []
        for op in operators:
            if op[0] == 1:
                self.set(op[1], op[2])
            else:
                ret.append(self.get(op[1]))

        return ret
```

</details>


<!--START_SECTION:relate-->
---

### 相关主题

<details><summary><b>设计</b></summary>

> [[中等, 剑指Offer] 队列的最大值](../01/剑指Offer_5902_中等_队列的最大值.md)  
> [[中等, 牛客] 字典树的实现](../05/牛客_0124_中等_字典树的实现.md)  
  > 
> [[困难, 剑指Offer] 数据流中的中位数](../../2021/12/剑指Offer_4100_困难_数据流中的中位数.md)  
> [[困难, 牛客] 设计LRU缓存结构 🔥](牛客_0093_困难_设计LRU缓存结构.md)  
  > 
> [[简单, 剑指Offer] 包含min函数的栈](../../2021/11/剑指Offer_3000_简单_包含min函数的栈.md)  
> [[简单, 剑指Offer] 用两个栈实现队列](../../2021/11/剑指Offer_0900_简单_用两个栈实现队列.md)  
  > 

</details>
<details><summary><b>经典</b></summary>

> [[中等, LeetCode] 下一个排列 🔥](../10/LeetCode_0031_中等_下一个排列.md)  
> [[中等, LeetCode] 二叉树的完全性检验 🔥](../03/LeetCode_0958_中等_二叉树的完全性检验.md)  
> [[中等, LeetCode] 最长递增子序列 🔥](../06/LeetCode_0300_中等_最长递增子序列.md)  
> [[中等, 剑指Offer2] 整数除法 🔥](../09/剑指Offer2_001_中等_整数除法.md)  
> [[中等, 剑指Offer] 丑数 🔥](../../2021/12/剑指Offer_4900_中等_丑数.md)  
> [[中等, 剑指Offer] 二叉搜索树与双向链表 🔥](../../2021/12/剑指Offer_3600_中等_二叉搜索树与双向链表.md)  
> [[中等, 剑指Offer] 圆圈中最后剩下的数字（约瑟夫环问题） 🔥](../01/剑指Offer_6200_中等_圆圈中最后剩下的数字（约瑟夫环问题）.md)  
> [[中等, 剑指Offer] 复杂链表的复制（深拷贝） 🔥](../../2021/12/剑指Offer_3500_中等_复杂链表的复制（深拷贝）.md)  
> [[中等, 剑指Offer] 字符串的排列（全排列） 🔥](../../2021/12/剑指Offer_3800_中等_字符串的排列（全排列）.md)  
> [[中等, 剑指Offer] 把字符串转换成整数 🔥](../01/剑指Offer_6700_中等_把字符串转换成整数.md)  
> [[中等, 剑指Offer] 数值的整数次方（快速幂） 🔥](../../2021/11/剑指Offer_1600_中等_数值的整数次方（快速幂）.md)  
> [[中等, 剑指Offer] 栈的压入、弹出序列 🔥](../../2021/11/剑指Offer_3100_中等_栈的压入、弹出序列.md)  
> [[中等, 剑指Offer] 重建二叉树 🔥](../../2021/11/剑指Offer_0700_中等_重建二叉树.md)  
> [[中等, 剑指Offer] 顺时针打印矩阵（3种思路4个写法） 🔥](../../2021/11/剑指Offer_2900_中等_顺时针打印矩阵（3种思路4个写法）.md)  
> [[中等, 牛客] 01背包 🔥](../05/牛客_0145_中等_01背包.md)  
> [[中等, 牛客] 丢棋子问题（鹰蛋问题） 🔥](牛客_0087_中等_丢棋子问题（鹰蛋问题）.md)  
> [[中等, 牛客] 字符串的排列 🔥](../05/牛客_0121_中等_字符串的排列.md)  
> [[中等, 牛客] 寻找峰值 🔥](牛客_0107_中等_寻找峰值.md)  
> [[中等, 牛客] 岛屿数量 🔥](牛客_0109_中等_岛屿数量.md)  
> [[中等, 牛客] 把字符串转换成整数(atoi) 🔥](牛客_0100_中等_把字符串转换成整数(atoi).md)  
> [[中等, 牛客] 数组中只出现一次的两个数字 🔥](../03/牛客_0075_中等_数组中只出现一次的两个数字.md)  
> [[中等, 牛客] 最长公共子序列(二) 🔥](牛客_0092_中等_最长公共子序列(二).md)  
> [[中等, 牛客] 栈和排序 🔥](../05/牛客_0115_中等_栈和排序.md)  
> [[中等, 牛客] 汉诺塔问题 🔥](../03/牛客_0067_中等_汉诺塔问题.md)  
  > 
> [[困难, LeetCode] 编辑距离 🔥](../06/LeetCode_0072_困难_编辑距离.md)  
> [[困难, 剑指Offer] 数组中的逆序对 🔥](../01/剑指Offer_5100_困难_数组中的逆序对.md)  
> [[困难, 牛客] 接雨水问题 🔥](../05/牛客_0128_困难_接雨水问题.md)  
> [[困难, 牛客] 设计LRU缓存结构 🔥](牛客_0093_困难_设计LRU缓存结构.md)  
  > 
> [[简单, LeetCode] 二叉树的最大深度 🔥](../07/LeetCode_0104_简单_二叉树的最大深度.md)  
> [[简单, LeetCode] 反转链表 🔥](../10/LeetCode_0206_简单_反转链表.md)  
> [[简单, 剑指Offer] 二叉搜索树的最近公共祖先 🔥](../01/剑指Offer_6801_简单_二叉搜索树的最近公共祖先.md)  
> [[简单, 剑指Offer] 反转链表 🔥](../../2021/11/剑指Offer_2400_简单_反转链表.md)  
> [[简单, 剑指Offer] 数组中出现次数超过一半的数字（摩尔投票） 🔥](../../2021/12/剑指Offer_3900_简单_数组中出现次数超过一半的数字（摩尔投票）.md)  
> [[简单, 剑指Offer] 最小的k个数（partition操作） 🔥](../../2021/12/剑指Offer_4000_简单_最小的k个数（partition操作）.md)  
> [[简单, 牛客] 二进制中1的个数 🔥](../05/牛客_0120_简单_二进制中1的个数.md)  
> [[简单, 牛客] 单链表的排序 🔥](../03/牛客_0070_简单_单链表的排序.md)  
> [[简单, 牛客] 求平方根 🔥](../02/牛客_0032_简单_求平方根.md)  
  > 

</details>
<!--END_SECTION:relate-->