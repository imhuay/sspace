## 判断一棵二叉树是否为搜索二叉树和完全二叉树
<!--START_SECTION:badge-->
![last modify](https://img.shields.io/static/v1?label=last%20modify&message=2025-07-08%2016%3A53%3A13&label_color=gray&color=thistle&style=flat-square)
[![](https://img.shields.io/static/v1?label=&message=%E4%B8%AD%E7%AD%89&label_color=gray&color=yellow&style=flat-square)](../../../README.md#中等)
[![](https://img.shields.io/static/v1?label=&message=%E7%89%9B%E5%AE%A2&label_color=gray&color=green&style=flat-square)](../../../README.md#牛客)
[![](https://img.shields.io/static/v1?label=&message=%E6%A0%91%E5%BD%A2%E9%80%92%E5%BD%92&label_color=gray&color=blue&style=flat-square)](../../../README.md#树形递归)
<!--END_SECTION:badge-->
<!--info
tags: [TreeDP]
source: 牛客
level: 中等
number: '0060'
name: 判断一棵二叉树是否为搜索二叉树和完全二叉树
companies: []
-->

> [判断一棵二叉树是否为搜索二叉树和完全二叉树_牛客题霸_牛客网](https://www.nowcoder.com/practice/f31fc6d3caf24e7f8b4deb5cd9b5fa97)

<summary><b>问题简述</b></summary>

```txt
给定一棵二叉树, 已知其中的节点没有重复值, 请判断该二叉树是否为搜索二叉树和完全二叉树.
输出描述: 分别输出是否为搜索二叉树、完全二叉树.
```

<!--
<details><summary><b>详细描述</b></summary>

```txt
```

</details>
-->


<!-- <div align="center"><img src="../../../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 判断二叉搜索树的条件:
    - 当前节点的值大于左树的最大值, 小于右树的最小值, 且**左右子树都是二叉搜索树**;
- 判断完全二叉树的条件:
    - 左右子树都是满二叉树, 且高度相同 (满二叉树) ;
    - 左右子树都是满二叉树, 且左子树的高度+1;
    - 左子树是满二叉树, 右子树是完全二叉树, 且高度相同;
    - 左子树是完全二叉树, 右子树是满二叉树, 且左子树的高度+1;
- 综上:
    - 我们需要存储信息有: 最大值、最小值、高度、是否二叉搜索树、是否满二叉树、是否完全二叉树;
    - 对空节点, 初始化为: 无穷小、无穷大、0、是、是、是;
- 详见代码;

<details><summary><b>Python</b></summary>

```python
class Solution:
    def judgeIt(self , root: TreeNode) -> List[bool]:

        from dataclasses import dataclass

        @dataclass
        class Info:
            mx: int  # 整棵树的最大值
            mi: int  # 整棵树的最小值
            height: int    # 树的高度
            is_bst: bool   # 是否搜索二叉树
            is_full: bool  # 是否满二叉树
            is_cbt: bool   # 是否完全二叉树

        def dfs(x):
            if not x: return Info(float('-inf'), float('inf'), 0, True, True, True)

            l, r = dfs(x.left), dfs(x.right)
            # 使用左右子树的信息得到当前节点的信息
            mx = max(x.val, r.mx)
            mi = min(x.val, l.mi)
            height = max(l.height, r.height) + 1
            is_bst = l.is_bst and r.is_bst and l.mx < x.val < r.mi
            is_full = l.is_full and r.is_full and l.height == r.height
            is_cbt = is_full or \
                l.is_full and r.is_full and l.height - 1 == r.height or \
                l.is_full and r.is_cbt and l.height == r.height or \
                l.is_cbt and r.is_full and l.height - 1 == r.height

            return Info(mx, mi, height, is_bst, is_full, is_cbt)

        info = dfs(root)
        return info.is_bst, info.is_cbt
```

</details>


<!--START_SECTION:relate-->
---

### 相关主题

<details><summary><b>树形递归</b></summary>

> [[中等, LeetCode] 打家劫舍III](../06/LeetCode_0337_中等_打家劫舍III.md)  
> [[中等, LeetCode] 路径总和III](../06/LeetCode_0437_中等_路径总和III.md)  
  > 
> [[困难, LeetCode] 二叉树中的最大路径和](../02/LeetCode_0124_困难_二叉树中的最大路径和.md)  
  > 
> [[简单, LeetCode] 平衡二叉树 🔥](../09/LeetCode_0110_简单_平衡二叉树.md)  
> [[简单, 剑指Offer] 二叉树的最近公共祖先](../01/剑指Offer_6802_简单_二叉树的最近公共祖先.md)  
  > 

</details>
<!--END_SECTION:relate-->