复合词检测
===
<!--START_SECTION:badge-->

![create date](https://img.shields.io/static/v1?label=create%20date&message=2025-08-21&label_color=gray&color=lightsteelblue&style=flat-square)
![last modify](https://img.shields.io/static/v1?label=last%20modify&message=2025-08-22%2003%3A35%3A56&label_color=gray&color=thistle&style=flat-square)

<!--END_SECTION:badge-->
<!--info
date: 2025-08-21 17:40:08
top: false
draft: false
hidden: false
level: 0
tag: [nlp_kg]
-->

<!--START_SECTION:keywords-->
> ***Keywords**: [短语挖掘](../07/短语挖掘.md)*
<!--END_SECTION:keywords-->

<!--START_SECTION:paper_title-->
<!--END_SECTION:paper_title-->

<!--START_SECTION:toc-->
- [背景](#背景)
- [一般方法](#一般方法)
<!--END_SECTION:toc-->

---

## 背景

**动机**: 把符合构词模式的复合词锁定为整体短语, 避免被 n-gram 分析阶段被拆开;


## 一般方法

1. **候选**: 发现复合词常见模式
    - 准备一批种子词;
    - 通过"**分词器**(Tokenizer) + **词性标注**(POS Tagging)"统计种子词的复合模式, 如 N + Adj, N + N, N + N + Adj 等;
    - 规则层输出的是候选短语集合;
2. **验证**: 
    - 计算**点互信息**(PMI, Pointwise Mutual Information);
        > [PMI 计算](./AutoPhrase备忘.md#pmi-计算)
    - 设置**最小频次** (min_freq), 避免极低频但 PMI 偏高的噪声组合;

**伪代码**
- 减少 PMI 计算的组合空间, 避免计算所有 n-gram;
- 对规则产出的候选再做相关性确认 (PMI + min_freq), 过滤掉偶然组合;
```python
for phrase in corpus:
    if POS_pattern(phrase) in {N+Adj, N+N, N+N+Adj}:
        pmi = calc_PMI(phrase)
        if pmi > threshold and freq(phrase) >= min_freq:
            add_to_protected_list(phrase)
```
