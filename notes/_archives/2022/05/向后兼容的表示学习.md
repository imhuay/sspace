向后兼容（Backward-Compatible）的表示学习
===
<!--START_SECTION:badge-->

![create date](https://img.shields.io/static/v1?label=create%20date&message=2022-05-xx&label_color=gray&color=lightsteelblue&style=flat-square)
![last modify](https://img.shields.io/static/v1?label=last%20modify&message=2025-08-03%2022%3A42%3A16&label_color=gray&color=thistle&style=flat-square)

<!--END_SECTION:badge-->
<!--info
top: false
draft: false
hidden: false
tag: [dl_embed]
-->

> ***Keywords**: 向后兼容的表示学习*

<!--START_SECTION:toc-->
- [背景](#背景)
- [引言](#引言)
- [方法](#方法)
    - [拓展](#拓展)
<!--END_SECTION:toc-->

---

## 背景

- 面试问题：**如何使两个模型输出的特征向量可比？**
    - 基本要求：使两个模型可比；
    - 进阶要求：记旧模型为 V1，新模型为 V2，两个模型输出的 Query 和 Doc 特征分别记为 Q1、Q2 和 D1、D2，期望 Q2-D2 > Q2-D1 > Q1-D1（准召等相关指标）；
        - 基本要求比较简单，比如在损失函数上加入正则化项，控制新旧模型的偏差；或者应用蒸馏学习的框架，等等；
        - 但是以上方法都不一定能满足进阶要求；
- 相关论文：[[2003.11942] Towards Backward-Compatible Representation Learning](https://arxiv.org/abs/2003.11942)
    - 论文导读：[Towards Backward-Compatible Representation Learning_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1d54y1i7Gs)

## 引言
- 在深度学习的背景下，搜索场景广泛引入了基于**向量召回**的方法，称为**向量化检索**（Embedding-based Retrieval）；
- 目前向量召回的常用方法是，基于参数共享的**双塔模型**将 Query 和 Doc 映射到同一向量空间；
- 一个良好的 Encoder（特征编码器）生成的向量（也称嵌入，Embedding）可以通过某种距离来衡量数据之间的相似性；或者说，可以在嵌入空间中对属于同一类的数据进行聚类；
    <!-- > 这里的 Query 和 Doc 均为图像，也可以是文本，但略有差异；图像查图像更像是一个分类/聚类任务，而文本查文本则是相似度任务，两者在大部分场景下不做区分，但分类一般在同模态数据中进行，相似度则没有这个要求； -->
- 在一个搜索系统中，为了快速响应，会预先对所有 Doc 构建索引（indexing），然后在查询时，通过一些先进的算法/框架，召回“相似”的结果；
    > **关键词**：最近邻搜索、Faiss；
- 随着数据不断增长、模型不断更新，Embedding 的质量越来越高；此时带来了一个问题，当使用新模型替换旧模型时，需要对全部 Doc 进行更新，即**重建索引**（reindexing、backfilling）；当 Doc 的规模非常大时，这件事的成本是非常高的；
- 针对这个问题，本文提出了一个新的研究方向，即**向后兼容的表示学习**；目的是在切换新模式时，不需要立即重建索引，通过新模型生成的 Query Embedding 可以跟旧模型的 Doc Embedding 进行比较，并且期望得到更好的准召效果；


## 方法
- 首先，论文假设 Encoder 的训练是基于一个分类任务来完成的；这也是目前图像领域大多数预训练模型的做法；这些模型在使用时，会将分类头移去，只使用由主干网络输出的向量作为 Embedding；
    > 值得注意的是，现在有很多表示学习是基于自监督的对比学习来完成的，且达到了 SOTA 水平，详见 [基于对比学习的表示学习训练框架](基于对比学习的表示学习训练框架.md)；但只要是基于分类任务，本文提出的方法理论上都是可以迁移的；
- 本文提出的方法很简单，简单来说，就是将旧模型训练完成后得到的分类头迁移到新模型上，并在训练期间固定住（fixed）；
    - 一个简单的解释：记由主干网络映射得到的空间为 V1，再经过分类头映射得到的空间为 V2；因为是相同的任务，所以可以认为新旧模型经过分类头后嵌入的空间，即 V2 是相同的，那么当我们进一步保持两个模型的分类头一致后，两个模型的主干网络所拟合的空间 V1 应该也是接近的；
    - 换一个角度，可以把分类头中的参数看做是一组**基向量**，我们假设两个模型经过这组基变换得到的空间是相同的（因为是一样的任务），当控制这组基向量一致后，新模型的主干网络也会逐渐向旧模型主干网络所输出的嵌入空间拟合；
    - 简单来说，一个 `A -> B -> C` 的过程，我们默认 `C`（分类嵌入空间） 是相同的，当进一步控制两个模型的 `B`（分类头） 也不变后，可以认为两个模型的 `A`（主干网络的嵌入空间） 也会非常接近；
- TODO：相关细节


### 拓展
- 固定分类头的做法也应用在了 [YiboYang2022](论文-2022-YiboYang.md) 中，本文的目标是使用一组预定义好的特殊向量（**等角紧框架**）作为分类头的权重，且不参与训练，目的是缓解不平衡学习中的问题；